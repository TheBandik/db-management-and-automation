# Триггеры

## Определение
Триггеры - это особые процедуры которые срабатывают при изменении данных в таблицы операторами `INSERT`, `UPDATE` и `DELETE`.
Триггеры могут срабатывать как до BEFORE так и после AFTER изменения таблицы. Получается, что триггер может быть в 6 состояниях:

| №   | Операция | Изменения      |
| --- | -------- | -------------- |
| 1   | INSERT   | BEFORE / AFTER |
| 2   | UPDATE   | BEFORE / AFTER |
| 3   | DELETE   | BEFORE / AFTER |


## Синтаксис
```sql
CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name
    FOR EACH ROW 
    trigger_stmt
```

Триггер становится связанным с таблицей с именем `tbl_name`, которое должно обратиться к постоянной таблице.

+ `trigger_time` задает время действия. Это может быть `BEFORE` или `AFTER`, чтобы задать, что триггер активизируется прежде или после инструкции, которая активизировала это
+ `trigger_event` указывает вид инструкции, которая активизирует триггер. Здесь trigger_event может быть одним из следующего:
    + `INSERT`: всякий раз, когда новая строка вставлена в таблицу. Например, через команды `INSERT`, `LOAD DATA` или `REPLACE`.
    + `UPDATE`: всякий раз, когда строка изменяется. Например, через инструкцию `UPDATE`.
    + `DELETE`: всякий раз, когда строка удалена из таблицы. Например, через инструкции `DELETE` и `REPLACE`. Однако, инструкции `DROP TABLE` и `TRUNCATE` относительно таблицы НЕ активизируют триггер, потому что они не используют `DELETE`!

## Создание триггера

### BEFORE INSERT
Для того чтобы понять работу триггера необходим пример

Задание
1.	Создать таблицу `user`, включающую поля `id`, `fam`, `name`, `otch`, `pass`
2.	Необходимо при добавлении записи в табл `user`, пароль преобразовывать в хеш, также имя и отчество преобразовывать в инициалы.

```sql
DELIMITER //

CREATE TRIGGER `test_user_pass` BEFORE INSERT ON `test`.`user`
    FOR EACH ROW
    BEGIN
        SET NEW.name = LEFT(NEW.name,1);
        SET NEW.otch = LEFT(NEW.otch,1);
        SET NEW.pass = md5(NEW.pass);
    END//
```

Теперь вставляем туда запись:

```sql
INSERT INTO `user` SET `fam`='Нагайченко', `name`='Максим', `otch` = 'Валерьевич', `pass` = 'password', `login` = 'maxnag';
```

Что теперь в таблице:

| id  | fam        | name | otch | pass                             | login  |
| --- | ---------- | ---- | ---- | -------------------------------- | ------ |
| 1   | Нагайченко | M    | В    | 5f4dcc3b5aa765d61d8327deb882cf99 | maxnag |

Как видно всего несколькими строчками можно убрать целые методы, которые мы использовали при регистрации нового пользователя.

### BEFORE UPDATE

Теперь еще надо создать триггер на ```UPDATE``` таблицы, с таким же телом, чтобы пользователь не смог записать полное имя, отчество и пароль не в md5

Создание триггера на ```BEFORE UPDATE```:
```sql
DELIMITER //

CREATE TRIGGER `test_user_pass2` BEFORE UPDATE ON `test`.`user`
    FOR EACH ROW
    BEGIN
        SET NEW.name = LEFT(NEW.name,1);
        SET NEW.otch = LEFT(NEW.otch,1);
        SET NEW.pass = md5(NEW.pass);
    END//
```

Обновление записи:

```sql
INSERT  INTO `user` SET `fam`='Нагайченко', `name`='Максим', `otch` = 'Валерьевич', `pass` = 'password', `login` = 'maxnag';
```


Итог:

| id  | fam    | name | otch | pass                             | login |
| --- | ------ | ---- | ---- | -------------------------------- | ----- |
| 1   | Иванов | И    | И    | e242f36f4f95f12966da8fa2efd59992 | ivan  |


Ключевые слова `OLD` и `NEW` дают возможность обратиться к столбцам в строках, на которые воздействует. Триггер `OLD` и `NEW` не чувствительны к регистру.

+ В триггере `INSERT` может использоваться только `NEW.col_name`: не имеется никакой старой строки.
+ В триггере `DELETE` не ожидается никакой новой строки, так что может использоваться исключительно `OLD.col_name`.
+ В триггере `UPDATE` вы можете использовать `OLD.col_name`, чтобы обратиться к столбцам строки прежде, чем они изменятся, и `NEW.col_name`, чтобы обратиться к ним уже после внесения изменений.





## Удаление триггера

Для удаления триггера используется, как обычно, оператор `DROP`, пример:

```sql
DROP TRIGGER [IF EXISTS] [schema_name.]trigger_name;
```

Где `schema_name` — название БД, `trigger_name` — название триггера

## Список созданных триггеров

Показать триггер можно с помощью команды:

```sql
SHOW TRIGGERS [{FROM | IN} db_name][LIKE 'pattern' | WHERE expr];
```
 
Это полная часть команды, в основном пользуются командами:

```sql
SHOW TRIGGERS [FROM db_name] [LIKE 'pattern'];
```

или

```sql
SHOW TRIGGERS;
```
Это полная часть команды, в основном пользуются командами:
1
2
3	SHOW TRIGGERS [FROM db_name] [LIKE 'pattern']
или
SHOW TRIGGERS

## Примеры

Имеется простой пример, который связывает триггер с таблицей для инструкций `INSERT`. Он действует как сумматор, чтобы суммировать значения, вставленные в один из столбцов таблицы.
Следующие инструкции создают таблицу и триггер для нее:

```sql
CREATE TABLE account (acct_num INT, amount DECIMAL(10,2));
CREATE TRIGGER ins_sum BEFORE INSERT ON account
    FOR EACH ROW SET sum = sum + NEW.amount;
```

Команда `CREATE TRIGGER` создает триггер `ins_sum`, который связан с таблицей `account`. Это также включает предложения, которые определяют время активации, событие вызова, и что делать с активированным триггером дальше:
+ Ключевое слово `BEFORE` указывает время срабатывания. В этом случае триггер должен активизировать перед каждой строкой, вставленной в таблицу
+ Ключевое слово `INSERT` указывает событие, которое активизирует триггер. В этом примере триггер срабатывает от инструкции `INSERT`
+ Инструкция `FOR EACH ROW` определяет, что триггер должен сработать один раз для каждой строки, на которую воздействует инструкция в примере. Собственно триггер представляет собой в данном случае простой `SET`, который накапливает значения, вставленные в столбец `amount`. Инструкция обращается к столбцу как `NEW.amount`, что означает "значение столбца `amount`, которое будет вставлено в новую строку"
  
Чтобы использовать триггер, установите переменную сумматора в ноль, выполните инструкцию `INSERT`, а затем посмотрите то, какое значение переменная имеет позже:

```sql
SET sum = 0;
INSERT INTO account VALUES(137, 14.98),(141, 1937.50),(97, -100.00);
SELECT sum AS 'Total amount inserted';
```

Вывод:
| Total amount inserted |
| --------------------- |
| 1852.48               |

В этом случае значение `sum` после выполнения команды `INSERT` равно `14.98 + 1937.50 - 100` или `1852.48`.

Используя конструкцию `BEGIN ... END`, вы можете определять триггер, который выполняет много инструкций. Внутри блока `BEGIN` вы также можете использовать другой синтаксис, который позволяется внутри сохраненных подпрограмм, типа условных выражений и циклов. Однако, точно как для сохраненных подпрограмм, если вы используете программу `mysql`, чтобы определить триггер, необходимо переопределить операторный разделитель `mysql` так, чтобы вы могли использовать `;` как операторный разделитель внутри описания триггера. 

Следующий пример иллюстрирует эти моменты. Это определяет триггер `UPDATE`, который проверяет новое значение, которое нужно использовать для модифицирования каждой строки, и изменяет значение, чтобы оставаться внутри диапазона от `0` до `100`. Это должно быть триггером типа `BEFORE`, потому что значение должно быть проверено прежде, чем оно используется, чтобы модифицировать строку:

```sql
delimiter //

CREATE TRIGGER upd_check BEFORE UPDATE ON account
    FOR EACH ROW
    BEGIN
        IF NEW.amount < 0 THEN SET NEW.amount = 0;
            ELSEIF NEW.amount > 100 THEN SET NEW.amount = 100;
        END IF;
    END//
```

Может быть проще определить сохраненную процедуру отдельно и затем вызвать ее из триггера простой инструкцией `CALL`. Это также выгодно, если вы хотите вызывать ту же самую подпрограмму изнутри нескольких триггеров.
